<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title></title>

<link rel="stylesheet" type="text/css" href="../stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="../stylesheets/syntaxhighlighter/shCore.css" />
<link rel="stylesheet" type="text/css" href="../stylesheets/syntaxhighlighter/shThemeFadeToGrey.css" />

<link rel="stylesheet" type="text/css" href="../stylesheets/fixes.css" />

</head>

<body class="guide">
  <div id="header">
      
  </div>
  <div id="index">
      
  </div>

  <div id="container">
    <h1>Solutions to problems from Colombian National Programming Contest 2011</h1>

<div class="author">
  <p class="name">by Andrés Mejía</p>
  <p class="date">October 16, 2011</p>
</div>

<p><a name="contents"></a></p>

<h2>Table of contents</h2>

<ul>
<li><a href="#solution-a">Solution to problem A - The Starflyer Agents</a></li>
<li><a href="#solution-b">Solution to problem B - Sewing Buttons with Grandma</a></li>
<li><a href="#solution-c">Solution to problem C - Document Compression</a></li>
<li><a href="#solution-d">Solution to problem D - Digital Roulette</a></li>
<li><a href="#solution-e">Solution to problem E - Edgetown&#39;s Traffic Jams</a></li>
<li><a href="#solution-f">Solution to problem F - Flight Control</a></li>
<li><a href="#solution-g">Solution to problem G - Gas Stations</a></li>
<li><a href="#solution-h">Solution to problem H - Handgun Shooting Sport</a></li>
<li><a href="#solution-i">Solution to problem I - Inspecting Radars</a></li>
<li><a href="#solution-j">Solution to problem J - Philip J. Fry Problem</a></li>
</ul>

<p><a name="solution-a"></a></p>

<h2>Solution to problem A - The Starflyer Agents</h2>

<p><a name="solution-b"></a></p>

<h2>Solution to problem B - Sewing Buttons with Grandma</h2>

<p><a name="solution-c"></a></p>

<h2>Solution to problem C - Document Compression</h2>

<p>The fact that&#39;s key to solve this problem is noticing that there are at most 16 different terms among all possible documents. This is good news because there are only <code>2^16 = 65536</code> different subsets of terms. Some of these subsets must be the documents we want to codify. Since this is a small number, we can simply precompute how many basis documents we need to form each of the 65536 possible subsets and then read the answer for each document we want to codify in <code>O(1)</code>.</p>

<p>When working with subsets, it&#39;s usually very helpful to use bitwise operations. We will represent a subset of terms <code>S</code> with a single integer <code>x</code>, where the <code>i</code>-th bit of <code>x</code> (in binary representation) is 1 if <code>i+1</code> is present in <code>S</code> and 0 otherwise. For example, if <code>S = {2, 3, 7, 15, 16}</code> then <code>x = 1100000001000110</code>:</p>

<p><img src="../images/binary_representation_of_sets.png" alt="Binary representation of sets"></p>

<p>This is useful because we can find the union of two subsets with a single bitwise <code>or</code>, which is blazingly fast and simple (we can also find the intersection with a bitwise <code>and</code>, but we don&#39;t need that in this problem).</p>

<p>Now, how do we find the minimum number of basis documents needed to form each possible subset of terms? Let&#39;s consider a graph where each node is a subset of terms and there&#39;s an edge from <code>u</code> to node <code>v</code> if we can mix <code>u</code> with a basis document and get <code>v</code>. It&#39;s easier to explain with an example, so let&#39;s imagine we have the following basis documents:</p>

<pre>
  b[0] = {1}
  b[1] = {1, 3}
  b[2] = {2, 4}
  b[3] = {1, 2, 3}
</pre>

<p>The graph we&#39;re talking about would look something like this (the index of the actual basis document that was used on each edge is shown in red):</p>

<p><img src="../images/document_graph.png" alt="Document graph"></p>

<p>Every path in this graph from <code>0000</code> to any node <code>v</code> represents a subset of basis documents that were chosen and mixed together to encode document <code>v</code>. Since we want to use the least possible number of basis documents, the answer is simply the shortest path in this graph (starting from <code>0000</code>).</p>

<p>For example, in the graph above we can see that the shortest path from <code>0000</code> to <code>0001</code> is 1. This means that we can form the document <code>{1}</code> using a single basis document (indeed, we just need <code>b[0]</code>). There are three different paths to <code>0111</code>; the shortest one has length 1. This means that we can form the document <code>{1, 2, 3}</code> with a single basis document (indeed, we just need <code>b[4]</code>). There are several paths to <code>1111</code>; the shortest one has length 2 (indeed, we can form <code>{1, 2, 3, 4}</code> mixing two basis documents, <code>b[2]</code> and <code>b[3]</code>, or <code>b[1]</code> and <code>b[2]</code>). There is no path to <code>0110</code>. This means we cannot form <code>{2, 3}</code> no matter how hard we try.</p>

<p>Since we have a directed graph where all edges have the same length, we can use a classical algorithm known as Breadth First Search (BFS) to find the shortest path from the first node to all others.</p>

<p>It&#39;s worth noting that we don&#39;t really need to explicitly build the graph above. We can just build it on the fly as we traverse it.</p>

<p>Here&#39;s a sample implementation in C++:</p>

<pre class="brush: cpp">
  Coming soon
</pre>

<h3>Exercises</h3>

<ul>
<li>Modify the algorithm above to not only tell what&#39;s the minimum number of basis documents needed, but actually tell which are the basis documents used.</li>
<li>Modify the algorithm above to calculate in how many different ways you can form some given document.</li>
</ul>

<p><a name="solution-d"></a></p>

<h2>Solution to problem D - Digital Roulette</h2>

<p>The problem can be rephrased as follows: count the number of different values of the expression <code>P(x) % (n + 1)</code> for all <code>x</code>&#39;s between 0 and <code>M</code>. Since the constraints are small (<code>M</code> ≤ 10000 and <code>k</code> ≤ 10), we can use brute force to evaluate the polynomial on every possible <code>x</code>.</p>

<p>There are two caveats, however:</p>

<p>First, notice that when evaluating the polynomial we&#39;ll have to compute expressions of the form <code>a[i] * x^i</code>. In the worst case, <code>i</code> might be as big as 10, <code>x</code> might be as big as 100000, and <code>a[i]</code> might be as big as 10000000, which means that <code>a[i] * x^i</code> might be as big as 10<sup>57.</sup> This doesn&#39;t fit in any native data type (recall that currently in C++ the biggest integer we can store in a native data type is 2<sup>64</sup> - 1 which fits in a <code>long long</code>).</p>

<p>Luckily, we don&#39;t really care about <code>a[i] * x^i</code>, we just care about <code>(a[i] * x^i) % (n + 1)</code>, so we can compute the expression without overflow. Recall from modular arithmetic properties that <code>(a * b) % n == ((a % n) * (b % n)) % n</code>, so we just have to compute <code>(a[i] * (x % (n + 1)) * (x % (n + 1)) * ... * (x % (n + 1))) % (n + 1)</code>, where there are exactly <code>i</code> <code>x</code>&#39;s in the expression (in other words, start with <code>a[i]</code> and multiply it <code>i</code> times with <code>x</code>, taking the result <code>% (n + 1)</code> after every step).</p>

<p>There&#39;s still a slight possibility of overflow: when we evaluate <code>(a[i] * x) % (n + 1)</code>, <code>a[i] * x</code> might be as big as 10<sup>7</sup> * 10<sup>5</sup> = 10<sup>12,</sup> but this fits comfortably in a <code>long long</code> so everything will be all right if we use <code>long long</code>s when calculating this product.</p>

<p>The second consideration is that since we are potentially evaluating the polynomial 10000 times, we need to be able to compute it as fast as possible. There&#39;s something known as Horner&#39;s rule, that lets us evaluate the polynomial in O(<code>n</code>), where <code>n</code> is its degree. This is fast enough. Basically, it&#39;s just a clever way of factoring out powers of <code>x</code>. Namely, Horner&#39;s rule says that:</p>

<p><img src="../images/horner.png" alt="Horner&#39;s Rule"></p>

<p>Finally, in C++, the easiest way to count the number of different answers is using a <code>set</code>. We just add all possible answers to the <code>set</code> and then ask for its size.</p>

<p>Here&#39;s a sample implementation in C++:</p>

<pre class="brush: cpp">
// Code written by Andrés Mejía
using namespace std;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

int main(){
    int n, m;
    while (cin &gt;&gt; n &gt;&gt; m) {
        if (n == 0 and m == 0) break;
        int k; cin &gt;&gt; k;
        vector&lt;int&gt; a(k + 1);
        // Read coefficients
        for (int i = 0; i &lt; k + 1; ++i) {
            cin &gt;&gt; a[i];
        }
        int mod = n + 1;
        set&lt;int&gt; ans;
        
        // Brute force on x
        for (int x = 0; x &lt;= m; x++){
            // calculate P(x) and store the result in y
            int y = 0, d = 1;
            for (int i = 0; i &lt; a.size(); ++i) {
                // At this point, d == (x^i) % mod
                y = (y + 1LL * a[i] * d) % mod; // the 1LL is to use long longs in the multiplication
                d = (1LL * d * x) % mod;
            }
            ans.insert(y);
        }
        cout &lt;&lt; ans.size() &lt;&lt; endl;
    }
    return 0;
}

</pre>

<p>The complexity of this algorithm is O(<code>m * k * log(n)</code>) (the <code>log</code> factor is what it takes to store a number in the <code>set</code>).</p>

<p><a href="#contents">Back to top</a></p>

<p><a name="solution-e"></a></p>

<h2>Solution to problem E - Edgetown&#39;s Traffic Jams</h2>

<p><a name="solution-f"></a></p>

<h2>Solution to problem F - Flight Control</h2>

<p><a name="solution-g"></a></p>

<h2>Solution to problem G - Gas Stations</h2>

<p><a name="solution-h"></a></p>

<h2>Solution to problem H - Handgun Shooting Sport</h2>

<p><a name="solution-i"></a></p>

<h2>Solution to problem I - Inspecting Radars</h2>

<p><a name="solution-j"></a></p>

<h2>Solution to problem J - Philip J. Fry Problem</h2>

  </div>

  <div id="footer">
  </div>

  <script type="text/javascript" src="../javascripts/syntaxhighlighter/shCore.js"></script>
  <script type="text/javascript" src="../javascripts/syntaxhighlighter/shBrushCpp.js"></script>
  <script type="text/javascript" src="../javascripts/syntaxhighlighter/shBrushPlain.js"></script>
  <script type="text/javascript">
    SyntaxHighlighter.all()
  </script>
</body>
</html>
